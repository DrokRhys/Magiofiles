/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD.
*/


"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MagiofilesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE = "magiofiles-view";
var DEFAULT_SETTINGS = {
  views: [{ id: "default", name: "Default", levels: [] }],
  activeViewId: "default",
  sortMode: "alpha",
  showFileIcons: true,
  showCounts: true
};
function normalizeTag(tag) {
  const t = tag.trim();
  if (!t) return "";
  return t.startsWith("#") ? t : `#${t}`;
}
var MagiofilesPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE,
      (leaf) => new MagiofilesView(leaf, this)
    );
    this.addRibbonIcon("folder", "Open Magiofiles", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-magiofiles-view",
      name: "Open Magiofiles panel",
      callback: () => this.activateView()
    });
    this.addSettingTab(new MagiofilesSettingTab(this.app, this));
    if (!this.app.workspace.getLeavesOfType(VIEW_TYPE).length) {
      this.activateView();
    }
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE)[0];
    if (!leaf) {
      leaf = workspace.getLeftLeaf(true);
      await leaf?.setViewState({ type: VIEW_TYPE, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  getActiveViewCfg() {
    const id = this.settings.activeViewId ?? this.settings.views[0].id;
    return this.settings.views.find((v) => v.id === id) ?? this.settings.views[0];
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE)) {
      const view = leaf.view;
      view?.render();
    }
  }
};
var MagiofilesView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.icon = "folder";
  }
  getDisplayText() {
    return "Magiofiles";
  }
  getViewType() {
    return VIEW_TYPE;
  }
  async onOpen() {
    const container = this.containerEl;
    container.empty();
    container.addClass("magiofiles-view");
    if (this.plugin.settings.showFileIcons) container.addClass("mgf-icons-on");
    else container.removeClass("mgf-icons-on");
    this.controlsEl = container.createDiv({ cls: "magiofiles-controls" });
    this.treeEl = container.createDiv({ cls: "magiofiles-tree nav-files nav-files-container" });
    this.syncNavVarsFromExplorer();
    window.setTimeout(() => this.syncNavVarsFromExplorer(), 250);
    window.setTimeout(() => this.syncNavVarsFromExplorer(), 1e3);
    this.registerEvent(this.app.workspace.on("layout-change", () => this.syncNavVarsFromExplorer()));
    this.render();
    this.registerEvent(this.app.workspace.on("file-open", (f) => {
      this.markSelected(f?.path ?? null);
    }));
  }
  async onClose() {
  }
  render() {
    this.renderControls();
    this.renderTree();
    const active = this.app.workspace.getActiveFile();
    this.markSelected(active?.path ?? null);
  }
  syncNavVarsFromExplorer() {
    try {
      const native = document.querySelector(
        ".workspace .nav-files-container:not(.magiofiles-tree)"
      );
      if (!native) return;
      const cs = getComputedStyle(native);
      const iconSize = cs.getPropertyValue("--icon-size") || "";
      const navIndent = cs.getPropertyValue("--nav-indentation") || "";
      const bg = cs.getPropertyValue("background-color") || "";
      if (iconSize) this.treeEl.style.setProperty("--icon-size", iconSize.trim());
      if (navIndent) this.treeEl.style.setProperty("--nav-indentation", navIndent.trim());
      if (bg) this.treeEl.style.setProperty("--mgf-nav-bg", bg.trim());
      const pl = cs.getPropertyValue("padding-left");
      const pr = cs.getPropertyValue("padding-right");
      const pt = cs.getPropertyValue("padding-top");
      const pb = cs.getPropertyValue("padding-bottom");
      const tree = this.treeEl;
      if (pt) tree.style.paddingTop = pt;
      if (pr) tree.style.paddingRight = pr;
      if (pb) tree.style.paddingBottom = pb;
      if (pl) tree.style.paddingLeft = pl;
    } catch {
    }
  }
  renderControls() {
    const cfg = this.plugin.getActiveViewCfg();
    this.controlsEl.empty();
    const toolbar = this.controlsEl.createDiv({ cls: "view-actions" });
    const levelsToggle = toolbar.createSpan({ cls: "clickable-icon" });
    (0, import_obsidian.setIcon)(levelsToggle, "settings");
    levelsToggle.setAttr("aria-label", "Levels");
    const sortBtn = toolbar.createSpan({ cls: "clickable-icon" });
    const sortIconName = this.plugin.settings.sortMode === "alpha" ? "arrow-up" : this.plugin.settings.sortMode === "alpha-desc" ? "arrow-down" : "bar-chart-2";
    (0, import_obsidian.setIcon)(sortBtn, sortIconName);
    sortBtn.setAttr("aria-label", "Sort");
    sortBtn.onclick = async (ev) => {
      const menu = new import_obsidian.Menu(this.app);
      menu.addItem((i) => i.setTitle("A \u2192 Z").setIcon("arrow-up").onClick(async () => {
        this.plugin.settings.sortMode = "alpha";
        await this.plugin.saveSettings();
      }));
      menu.addItem((i) => i.setTitle("Z \u2192 A").setIcon("arrow-down").onClick(async () => {
        this.plugin.settings.sortMode = "alpha-desc";
        await this.plugin.saveSettings();
      }));
      menu.addItem((i) => i.setTitle("Count (desc)").setIcon("bar-chart-2").onClick(async () => {
        this.plugin.settings.sortMode = "count";
        await this.plugin.saveSettings();
      }));
      menu.showAtMouseEvent(ev);
    };
    const viewsBtn = toolbar.createSpan({ cls: "clickable-icon" });
    (0, import_obsidian.setIcon)(viewsBtn, "layers");
    viewsBtn.setAttr("aria-label", "Views");
    viewsBtn.onclick = (ev) => {
      const menu = new import_obsidian.Menu(this.app);
      for (const v of this.plugin.settings.views) {
        menu.addItem(
          (i) => i.setTitle(v.name).setIcon(v.id === (this.plugin.settings.activeViewId ?? "default") ? "check" : "circle").onClick(async () => {
            this.plugin.settings.activeViewId = v.id;
            await this.plugin.saveSettings();
          })
        );
      }
      menu.showAtMouseEvent(ev);
    };
    const tagCounts = collectTagCounts(this.app).sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));
    const levelsWrap = this.controlsEl.createDiv({ cls: "magiofiles-levels" });
    levelsWrap.style.display = "none";
    levelsToggle.onclick = async () => {
      const visible = levelsWrap.style.display !== "none";
      if (visible) {
        levelsWrap.style.display = "none";
        this.controlsEl.removeClass("has-levels-open");
        return;
      }
      if (cfg.levels.length === 0) {
        cfg.levels.push({ name: "Level 1", tags: [] });
        await this.plugin.saveSettings();
        this.renderControls();
        const nw = this.controlsEl.querySelector(".magiofiles-levels");
        if (nw) nw.style.display = "block";
        this.controlsEl.addClass("has-levels-open");
        return;
      }
      levelsWrap.style.display = "block";
      this.controlsEl.addClass("has-levels-open");
    };
    const header = levelsWrap.createDiv({ text: "Levels (tags form folders)" });
    header.addClass("mgf-muted");
    cfg.levels.forEach((level, idx) => {
      const row = levelsWrap.createDiv({ cls: "magiofiles-level" });
      const nameInput = row.createEl("input", { type: "text", value: level.name || `Level ${idx + 1}` });
      nameInput.onchange = async () => {
        level.name = nameInput.value || `Level ${idx + 1}`;
        await this.plugin.saveSettings();
      };
      const pickerWrap = row.createDiv({ cls: "mgf-tagpicker", attr: { "data-idx": String(idx) } });
      createTagPicker(pickerWrap, level.tags.map(stripHash), tagCounts, async (tagsNoHash) => {
        level.tags = tagsNoHash.map(normalizeTag);
        await this.plugin.saveSettings();
      });
      const delBtn = row.createEl("button", { text: "Remove" });
      delBtn.onclick = async () => {
        cfg.levels.splice(idx, 1);
        await this.plugin.saveSettings();
      };
    });
    const addLevelBtn = levelsWrap.createEl("button", { text: "+ Add level" });
    addLevelBtn.onclick = async () => {
      cfg.levels.push({ name: `Level ${cfg.levels.length + 1}`, tags: [] });
      await this.plugin.saveSettings();
    };
  }
  renderTree() {
    const cfg = this.plugin.getActiveViewCfg();
    this.treeEl.empty();
    const allFiles = this.app.vault.getFiles();
    const mdFiles = this.app.vault.getMarkdownFiles();
    if (!allFiles.length) {
      this.treeEl.createDiv({ text: "No files.", cls: "mgf-muted" });
      return;
    }
    const fileTags = /* @__PURE__ */ new Map();
    for (const f of mdFiles) fileTags.set(f, collectTagsForFile(this.app, f));
    const matched = /* @__PURE__ */ new Set();
    for (const f of mdFiles) {
      let any = false;
      for (const lvl of cfg.levels) {
        if (tagMatchesAny(fileTags.get(f) ?? /* @__PURE__ */ new Set(), lvl.tags)) {
          any = true;
          break;
        }
      }
      if (any) matched.add(f);
    }
    const tagsRoot = { name: "root", level: -1, files: new Set(matched), children: /* @__PURE__ */ new Map() };
    for (let lv = 0; lv < cfg.levels.length; lv++) {
      const levelCfg = cfg.levels[lv];
      propagateLevel(tagsRoot, levelCfg.tags, fileTags, lv);
    }
    const folderRoot = { name: "root", level: -1, children: /* @__PURE__ */ new Map(), files: /* @__PURE__ */ new Set() };
    for (const f of allFiles) {
      if (matched.has(f)) continue;
      addFileToFolderTree(folderRoot, f.path, f);
    }
    const tagsItem = this.treeEl.createDiv({ cls: "tree-item nav-folder mod-root has-children" });
    const tagsSelf = tagsItem.createDiv({ cls: "tree-item-self nav-folder-title" });
    const tagsChevron = tagsSelf.createSpan({ cls: "tree-item-icon collapse-icon nav-folder-collapse-indicator" });
    (0, import_obsidian.setIcon)(tagsChevron, "chevron-down");
    const tagsIconSpacer = tagsSelf.createSpan({ cls: "tree-item-icon" });
    (0, import_obsidian.setIcon)(tagsIconSpacer, "folder");
    tagsIconSpacer.style.opacity = "0";
    tagsIconSpacer.style.pointerEvents = "none";
    tagsIconSpacer.setAttr("aria-hidden", "true");
    tagsSelf.createSpan({ text: "By Tags", cls: "tree-item-inner" });
    if (this.plugin.settings.showCounts) {
      tagsSelf.createSpan({ text: ` (${countFiles(tagsRoot)})`, cls: "tree-item-flair" });
    }
    const tagsWrap = tagsItem.createDiv({ cls: "tree-item-children nav-folder-children" });
    let tagsExpanded = true;
    const toggleTags = () => {
      tagsExpanded = !tagsExpanded;
      tagsItem.toggleClass("is-collapsed", !tagsExpanded);
      tagsSelf.setAttr("aria-expanded", tagsExpanded ? "true" : "false");
      tagsSelf.toggleClass("is-collapsed", !tagsExpanded);
      tagsWrap.style.display = tagsExpanded ? "block" : "none";
    };
    tagsSelf.onclick = toggleTags;
    if (tagsRoot.children && tagsRoot.children.size) {
      for (const [name, child] of getSortedEntries(tagsRoot.children, this.plugin.settings.sortMode)) this.renderGroup(child, tagsWrap, name);
    } else {
      tagsWrap.createDiv({ text: "Empty", cls: "mgf-muted" });
    }
    const folderItem = this.treeEl.createDiv({ cls: "tree-item nav-folder mod-root has-children" });
    const folderSelf = folderItem.createDiv({ cls: "tree-item-self nav-folder-title" });
    const folderChevron = folderSelf.createSpan({ cls: "tree-item-icon collapse-icon nav-folder-collapse-indicator" });
    (0, import_obsidian.setIcon)(folderChevron, "chevron-down");
    const folderIconSpacer = folderSelf.createSpan({ cls: "tree-item-icon" });
    (0, import_obsidian.setIcon)(folderIconSpacer, "folder");
    folderIconSpacer.style.opacity = "0";
    folderIconSpacer.style.pointerEvents = "none";
    folderIconSpacer.setAttr("aria-hidden", "true");
    folderSelf.createSpan({ text: "By Folder", cls: "tree-item-inner" });
    if (this.plugin.settings.showCounts) {
      folderSelf.createSpan({ text: ` (${countFiles(folderRoot)})`, cls: "tree-item-flair" });
    }
    const folderWrap = folderItem.createDiv({ cls: "tree-item-children nav-folder-children" });
    let folderExpanded = true;
    const toggleFolder = () => {
      folderExpanded = !folderExpanded;
      folderItem.toggleClass("is-collapsed", !folderExpanded);
      folderSelf.setAttr("aria-expanded", folderExpanded ? "true" : "false");
      folderSelf.toggleClass("is-collapsed", !folderExpanded);
      folderWrap.style.display = folderExpanded ? "block" : "none";
    };
    folderSelf.onclick = toggleFolder;
    if (folderRoot.children && folderRoot.children.size) {
      for (const [name, child] of getSortedEntries(folderRoot.children, this.plugin.settings.sortMode)) this.renderGroup(child, folderWrap, name);
    }
    if (folderRoot.files && folderRoot.files.size) {
      for (const f of [...folderRoot.files].sort((a, b) => a.basename.localeCompare(b.basename))) this.renderFile(f, folderWrap);
    }
  }
  renderGroup(node, parent, displayName) {
    const item = parent.createDiv({ cls: "tree-item nav-folder has-children" });
    const self = item.createDiv({ cls: "tree-item-self nav-folder-title" });
    const chevron = self.createSpan({ cls: "tree-item-icon collapse-icon nav-folder-collapse-indicator" });
    (0, import_obsidian.setIcon)(chevron, "chevron-down");
    const iconSpacer = self.createSpan({ cls: "tree-item-icon" });
    (0, import_obsidian.setIcon)(iconSpacer, "folder");
    iconSpacer.style.opacity = "0";
    iconSpacer.style.pointerEvents = "none";
    iconSpacer.setAttr("aria-hidden", "true");
    self.createSpan({ text: displayName, cls: "tree-item-inner" });
    if (this.plugin.settings.showCounts) {
      const count = countFiles(node);
      self.createSpan({ text: ` (${count})`, cls: "tree-item-flair" });
    }
    const childrenWrap = item.createDiv({ cls: "tree-item-children nav-folder-children" });
    let expanded = true;
    const toggle = () => {
      expanded = !expanded;
      item.toggleClass("is-collapsed", !expanded);
      self.setAttr("aria-expanded", expanded ? "true" : "false");
      self.toggleClass("is-collapsed", !expanded);
      childrenWrap.style.display = expanded ? "block" : "none";
    };
    self.onclick = toggle;
    if (node.children && node.children.size) {
      for (const [name, child] of getSortedEntries(node.children, this.plugin.settings.sortMode)) this.renderGroup(child, childrenWrap, name);
    }
    if (node.files && node.files.size) {
      for (const f of [...node.files].sort((a, b) => a.basename.localeCompare(b.basename))) this.renderFile(f, childrenWrap);
    }
  }
  renderFile(file, parent) {
    const item = parent.createDiv({ cls: "tree-item nav-file" });
    const self = item.createDiv({ cls: "tree-item-self nav-file-title" });
    if (this.plugin.settings.showFileIcons) {
      const ico = self.createSpan({ cls: "tree-item-icon" });
      (0, import_obsidian.setIcon)(ico, "file");
    }
    const name = self.createSpan({ cls: "tree-item-inner" });
    name.setText(file.basename);
    self.dataset.path = file.path;
    item.onclick = () => {
      this.app.workspace.getLeaf(true).openFile(file);
      this.markSelected(file.path);
    };
  }
  markSelected(path) {
    const nodes = this.treeEl.querySelectorAll(".nav-file .nav-file-title");
    nodes.forEach((el) => {
      const isActive = (el.dataset.path ?? "") === (path ?? "");
      el.toggleClass("is-active", isActive);
      el.toggleClass("is-selected", isActive);
    });
  }
};
function collectTagsForFile(app, file) {
  const cache = app.metadataCache.getFileCache(file);
  const out = /* @__PURE__ */ new Set();
  const inline = cache?.tags ?? [];
  for (const t of inline) out.add(t.tag);
  const fm = cache?.frontmatter;
  const fmTags = fm?.tags;
  if (typeof fmTags === "string") out.add(normalizeTag(fmTags));
  else if (Array.isArray(fmTags)) for (const t of fmTags) out.add(normalizeTag(String(t)));
  return out;
}
function collectTagCounts(app) {
  const map = /* @__PURE__ */ new Map();
  const files = app.vault.getMarkdownFiles();
  for (const f of files) {
    const set = collectTagsForFile(app, f);
    for (const t of set) {
      const key = stripHash(t);
      map.set(key, (map.get(key) ?? 0) + 1);
    }
  }
  return [...map.entries()].map(([name, count]) => ({ name, count }));
}
function tagMatchesAny(tagSet, wanted) {
  for (const w of wanted) {
    for (const t of tagSet) {
      if (t === w || t.startsWith(w + "/")) return w;
    }
  }
  return null;
}
function propagateLevel(root, levelTags, fileTags, levelIdx) {
  const queue = [root];
  while (queue.length) {
    const node = queue.pop();
    if (!node.files || !node.files.size) {
      if (node.children) for (const child of node.children.values()) queue.push(child);
      continue;
    }
    node.children = node.children ?? /* @__PURE__ */ new Map();
    const remaining = [];
    for (const f of node.files) {
      const match = tagMatchesAny(fileTags.get(f), levelTags);
      if (match) {
        const key = stripHash(match);
        let bucket = node.children.get(key);
        if (!bucket) {
          bucket = { name: key, level: levelIdx, children: /* @__PURE__ */ new Map(), files: /* @__PURE__ */ new Set() };
          node.children.set(key, bucket);
        }
        bucket.files.add(f);
      } else {
        remaining.push(f);
      }
    }
    if (remaining.length) {
      const key = "Others";
      let bucket = node.children.get(key);
      if (!bucket) {
        bucket = { name: key, level: levelIdx, children: /* @__PURE__ */ new Map(), files: /* @__PURE__ */ new Set() };
        node.children.set(key, bucket);
      }
      for (const f of remaining) bucket.files.add(f);
    }
    node.files.clear();
  }
}
function stripHash(tag) {
  return tag.startsWith("#") ? tag.slice(1) : tag;
}
function countFiles(node) {
  let sum = 0;
  if (node.files) sum += node.files.size;
  if (node.children) for (const child of node.children.values()) sum += countFiles(child);
  return sum;
}
function addFileToFolderTree(root, fullPath, file) {
  const parts = fullPath.split("/");
  const fileName = parts.pop();
  let node = root;
  for (const folderName of parts) {
    node.children = node.children ?? /* @__PURE__ */ new Map();
    let next = node.children.get(folderName);
    if (!next) {
      next = { name: folderName, level: (node.level ?? -1) + 1, children: /* @__PURE__ */ new Map(), files: /* @__PURE__ */ new Set() };
      node.children.set(folderName, next);
    }
    node = next;
  }
  node.files = node.files ?? /* @__PURE__ */ new Set();
  node.files.add(file);
}
function getSortedEntries(map, mode) {
  const arr = [...map.entries()];
  if (mode === "count") {
    return arr.sort((a, b) => {
      const ca = countFiles(a[1]);
      const cb = countFiles(b[1]);
      if (cb !== ca) return cb - ca;
      return a[0].localeCompare(b[0]);
    });
  }
  if (mode === "alpha-desc") {
    return arr.sort((a, b) => b[0].localeCompare(a[0]));
  }
  return arr.sort((a, b) => a[0].localeCompare(b[0]));
}
var MagiofilesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Magiofiles \u2013 Views & Levels" });
    new import_obsidian.Setting(containerEl).setName("Active view").setDesc("Select which view to show in the panel.").addDropdown((dd) => {
      for (const v of this.plugin.settings.views) dd.addOption(v.id, v.name);
      dd.setValue(this.plugin.settings.activeViewId ?? "default");
      dd.onChange(async (val) => {
        this.plugin.settings.activeViewId = val;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Show file icons").setDesc("Display icons next to files in the tree.").addToggle((t) => t.setValue(this.plugin.settings.showFileIcons).onChange(async (v) => {
      this.plugin.settings.showFileIcons = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show counts").setDesc("Display file counts next to folders.").addToggle((t) => t.setValue(this.plugin.settings.showCounts).onChange(async (v) => {
      this.plugin.settings.showCounts = v;
      await this.plugin.saveSettings();
    }));
    const list = containerEl.createDiv();
    for (const view of this.plugin.settings.views) {
      const box = list.createDiv({ cls: "setting-item" });
      const info = box.createDiv({ cls: "setting-item-info" });
      info.createEl("div", { text: view.name, cls: "setting-item-name" });
      info.createEl("div", { text: `Levels: ${view.levels.length}`, cls: "setting-item-description" });
      const ctrl = box.createDiv({ cls: "setting-item-control" });
      const rename = ctrl.createEl("button", { text: "Rename" });
      rename.onclick = async () => {
        const n = await promptModal(this.app, "View name", view.name);
        if (n) {
          view.name = n;
          await this.plugin.saveSettings();
          this.display();
        }
      };
      const remove = ctrl.createEl("button", { text: "Delete" });
      remove.onclick = async () => {
        if (this.plugin.settings.views.length === 1) return new import_obsidian.Notice("At least one view must remain.");
        this.plugin.settings.views = this.plugin.settings.views.filter((v) => v.id !== view.id);
        if (this.plugin.settings.activeViewId === view.id) this.plugin.settings.activeViewId = this.plugin.settings.views[0].id;
        await this.plugin.saveSettings();
        this.display();
      };
      const dup = ctrl.createEl("button", { text: "Duplicate" });
      dup.onclick = async () => {
        const copy = {
          id: `view-${Date.now()}`,
          name: view.name + " (copy)",
          levels: JSON.parse(JSON.stringify(view.levels))
        };
        this.plugin.settings.views.push(copy);
        await this.plugin.saveSettings();
        this.display();
      };
    }
    new import_obsidian.Setting(containerEl).setName("New view").setDesc("Create another empty view.").addButton(
      (b) => b.setButtonText("Add").onClick(async () => {
        const name = await promptModal(this.app, "New view name", "New view");
        const v = { id: `view-${Date.now()}`, name: name ?? "New view", levels: [] };
        this.plugin.settings.views.push(v);
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
};
async function promptModal(app, title, value) {
  return Promise.resolve(window.prompt(title, value));
}
function createTagPicker(parent, initial, suggestions, onChange) {
  let selected = Array.from(new Set(initial.map(stripHash)));
  parent.empty();
  parent.addClass("mgf-tagpicker");
  parent.style.position = "relative";
  const list = parent.createDiv({ cls: "mgf-chip-list" });
  const input = parent.createEl("input", { type: "text" });
  input.addClass("mgf-taginput");
  input.placeholder = selected.length ? "" : "tag1, tag2/sub";
  const dropdown = parent.createDiv({ cls: "mgf-suggest" });
  dropdown.hide();
  function renderChips() {
    list.empty();
    for (const t of selected) {
      const chip = list.createSpan({ cls: "mgf-chip" });
      chip.createSpan({ text: t });
      const rm = chip.createSpan({ cls: "mgf-chip-x", text: "\xD7" });
      rm.onclick = () => {
        selected = selected.filter((x) => x !== t);
        renderChips();
        onChange(selected);
        updateDropdown();
      };
    }
  }
  function updateDropdown() {
    const q = input.value.trim().toLowerCase();
    dropdown.empty();
    const avail = suggestions.filter((s) => !selected.includes(s.name));
    const filtered = q ? avail.filter((s) => s.name.toLowerCase().includes(q)) : avail;
    if (!filtered.length) {
      dropdown.hide();
      return;
    }
    for (const s of filtered.slice(0, 400)) {
      const item = dropdown.createDiv({ cls: "mgf-suggest-item" });
      item.createSpan({ text: s.name });
      const c = item.createSpan({ cls: "mgf-muted", text: ` (${s.count})` });
      item.onclick = () => {
        if (!selected.includes(s.name)) selected.push(s.name);
        input.value = "";
        renderChips();
        onChange(selected);
        updateDropdown();
        input.focus();
      };
    }
    dropdown.show();
  }
  function commitInput() {
    const raw = input.value.split(",").map((x) => x.trim()).filter(Boolean);
    if (!raw.length) return;
    for (const r of raw) if (!selected.includes(r)) selected.push(r);
    input.value = "";
    renderChips();
    onChange(selected);
    updateDropdown();
  }
  input.oninput = () => updateDropdown();
  input.onfocus = () => updateDropdown();
  input.onblur = () => setTimeout(() => dropdown.hide(), 150);
  input.onkeydown = (ev) => {
    if (ev.key === "Enter" || ev.key === ",") {
      ev.preventDefault();
      commitInput();
    } else if (ev.key === "Backspace" && !input.value && selected.length) {
      selected.pop();
      renderChips();
      onChange(selected);
      updateDropdown();
    }
  };
  parent.onclick = (e) => {
    if (e.target === parent) input.focus();
  };
  renderChips();
}
